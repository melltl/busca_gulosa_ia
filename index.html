<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greedy Search Grid Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(11, 30px);
            gap: 1px;
            margin-bottom: 20px;
        }
        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 10px; /* Reduzido para caber no quadrado */
            text-align: center;
        }
        .wall { background-color: #333; }
        .start { background-color: #4CAF50; }
        .end { background-color: #F44336; }
        .path { background-color: #2196F3; }
        .visited { background-color: #FFC107; }
        button {
            margin: 5px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greedy Search Grid Visualization</h1>
        <div id="grid"></div>
        <div>
            <button id="setStart">Set Start</button>
            <button id="setEnd">Set End</button>
            <button id="toggleWall">Toggle Wall</button>
            <button id="startSearch">Start Search</button>
            <button id="reset">Reset</button>
        </div>
    </div>
    <script>
        const grid = document.getElementById('grid');
        const cells = [];
        let start = null;
        let end = null;
        let currentMode = 'wall';

        // Create grid
        for (let y = 0; y < 11; y++) {
            for (let x = 0; x < 11; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                cell.addEventListener('click', () => handleCellClick(x, y));
                grid.appendChild(cell);
                cells.push(cell);
            }
        }

        function handleCellClick(x, y) {
            const cell = cells[y * 11 + x];
            if (currentMode === 'wall') {
                cell.classList.toggle('wall');
            } else if (currentMode === 'start' && !start) {
                start = {x, y};
                cell.classList.add('start');
            } else if (currentMode === 'end' && !end) {
                end = {x, y};
                cell.classList.add('end');
            }
        }

        document.getElementById('setStart').addEventListener('click', () => currentMode = 'start');
        document.getElementById('setEnd').addEventListener('click', () => currentMode = 'end');
        document.getElementById('toggleWall').addEventListener('click', () => currentMode = 'wall');
        document.getElementById('startSearch').addEventListener('click', startSearch);
        document.getElementById('reset').addEventListener('click', resetGrid);

        function resetGrid() {
            cells.forEach(cell => {
                cell.className = 'cell';
                cell.innerText = ''; // Clear any text (cost values)
            });
            start = null;
            end = null;
        }

        function heuristic(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                if (newX >= 0 && newX < 11 && newY >= 0 && newY < 11) {
                    const cell = cells[newY * 11 + newX];
                    if (!cell.classList.contains('wall')) {
                        neighbors.push({x: newX, y: newY});
                    }
                }
            }
            return neighbors;
        }

        async function startSearch() {
            if (!start || !end) {
                alert('Please set start and end points');
                return;
            }

            const frontier = [{node: start, priority: heuristic(start, end)}];
            const cameFrom = new Map();
            const visited = new Set();

            while (frontier.length > 0) {
                frontier.sort((a, b) => a.priority - b.priority);
                const current = frontier.shift().node;
                
                if (current.x === end.x && current.y === end.y) {
                    break;
                }

                for (const next of getNeighbors(current.x, current.y)) {
                    const key = `${next.x},${next.y}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        cameFrom.set(key, current);
                        frontier.push({node: next, priority: heuristic(next, end)});
                        if (!(next.x === end.x && next.y === end.y) && !(next.x === start.x && next.y === start.y)) {
                            cells[next.y * 11 + next.x].classList.add('visited');

                            // Calculate and display the cost (distance from end)
                            const cost = heuristic(end, next).toFixed(2);
                            cells[next.y * 11 + next.x].innerText = cost;
                        }
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
            }

            // Reconstruct path
            let current = end;
            while (current.x !== start.x || current.y !== start.y) {
                const key = `${current.x},${current.y}`;
                current = cameFrom.get(key);
                if (!(current.x === start.x && current.y === start.y) && !(current.x === end.x && current.y === end.y)) {
                    cells[current.y * 11 + current.x].classList.remove('visited');
                    cells[current.y * 11 + current.x].classList.add('path');
                }
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }
    </script>
</body>
</html>
